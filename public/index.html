<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ping Pong Tournament Scheduler</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const API_BASE = '/api';

        const groups = {
          A: ['Michael Schmidt', 'Niketha Kailash', 'Brian Pleiman', 'Dylan Rasmussen', 'Extra 1'],
          B: ['Ritesh Varma', 'Emma Gerken', 'Spencer Chamberlain', 'Michael Mpitsos', 'Michelle Caye'],
          C: ['Jonathan Friend', 'Eric Miller', 'Sivakumar Ramamurthy', 'Dave Sanders', 'Adam Kelly'],
          D: ['Laura Harrah', 'Alan Smith', 'Cameron McLain', 'Scott Treml', 'Extra 3'],
          E: ['Karen Isaacs', 'Sarah Sunderhaus', 'Allie Shaw', 'Caterina Rizzoni', 'Neha']
        };

        const allPlayers = Object.values(groups).flat();
        const dates = ['12/9', '12/10', '12/11'];

        const generateTimeSlots = () => {
          const slots = [];
          for (let hour = 8; hour < 17; hour++) {
            for (let min = 0; min < 60; min += 20) {
              if (hour === 16 && min > 40) break;
              slots.push(`${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`);
            }
          }
          return slots;
        };

        const timeSlots = generateTimeSlots();
        const formatTime = (time) => {
          const [hour, min] = time.split(':');
          const h = parseInt(hour);
          return `${h > 12 ? h - 12 : h}:${min} ${h >= 12 ? 'PM' : 'AM'}`;
        };

        const getMatchId = (p1, p2) => [p1, p2].sort().join('|');
        const getPlayerGroup = (player) => Object.entries(groups).find(([g, p]) => p.includes(player))?.[0];

        function MatchResultForm({ match, onComplete }) {
          const [winner, setWinner] = useState(null);
          const [score1, setScore1] = useState('');
          const [score2, setScore2] = useState('');

          const handleSubmit = () => {
            if (!winner || score1 === '' || score2 === '') return;
            onComplete(match.id, winner, parseInt(score1), parseInt(score2));
          };

          return (
            <div className="bg-slate-800/50 rounded-lg p-2 space-y-2">
              <div className="flex items-center gap-2">
                <span className="text-xs text-slate-500">Winner:</span>
                {[match.player1, match.player2].map(p => (
                  <button key={p} onClick={() => setWinner(p)}
                    className={`text-xs px-2 py-1 rounded-lg transition ${winner === p ? 'bg-emerald-500 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>{p.split(' ')[0]}</button>
                ))}
              </div>
              <div className="flex items-center gap-2">
                <span className="text-xs text-slate-500">Score:</span>
                <input type="number" min="0" max="99" value={score1} onChange={e => setScore1(e.target.value)} placeholder="0" className="w-12 bg-slate-700 text-white text-center text-sm rounded px-2 py-1" />
                <span className="text-slate-500">-</span>
                <input type="number" min="0" max="99" value={score2} onChange={e => setScore2(e.target.value)} placeholder="0" className="w-12 bg-slate-700 text-white text-center text-sm rounded px-2 py-1" />
                <button onClick={handleSubmit} disabled={!winner || score1 === '' || score2 === ''}
                  className="text-xs bg-violet-600 hover:bg-violet-500 disabled:bg-slate-700 disabled:text-slate-500 text-white px-3 py-1 rounded-lg ml-auto transition">Save</button>
              </div>
            </div>
          );
        }

        const generateAllMatches = () => {
          const matches = {};
          Object.entries(groups).forEach(([group, players]) => {
            for (let i = 0; i < players.length; i++) {
              for (let j = i + 1; j < players.length; j++) {
                const id = getMatchId(players[i], players[j]);
                matches[id] = { id, group, player1: players[i], player2: players[j], lockedDate: null, lockedTime: null, winner: null, score1: null, score2: null, completed: false };
              }
            }
          });
          return matches;
        };

        function App() {
          const [currentUser, setCurrentUser] = useState(null);
          const [activeGroup, setActiveGroup] = useState('A');
          const [selectedDate, setSelectedDate] = useState(dates[0]);
          const [availability, setAvailability] = useState({});
          const [matches, setMatches] = useState(generateAllMatches);
          const [view, setView] = useState('availability');
          const [loading, setLoading] = useState(true);

          useEffect(() => {
            loadData();
          }, []);

          const loadData = async () => {
            try {
              const [availRes, matchRes] = await Promise.all([
                fetch(`${API_BASE}/availability`),
                fetch(`${API_BASE}/matches`)
              ]);
              const availData = await availRes.json();
              const matchData = await matchRes.json();
              if (availData && Object.keys(availData).length > 0) setAvailability(availData);
              if (matchData && Object.keys(matchData).length > 0) setMatches(matchData);
            } catch (e) {
              console.error('Error loading data:', e);
            }
            setLoading(false);
          };

          const saveAvailability = async (newAvail) => {
            setAvailability(newAvail);
            try {
              await fetch(`${API_BASE}/availability`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newAvail)
              });
            } catch (e) {
              console.error('Error saving availability:', e);
            }
          };

          const saveMatches = async (newMatches) => {
            setMatches(newMatches);
            try {
              await fetch(`${API_BASE}/matches`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newMatches)
              });
            } catch (e) {
              console.error('Error saving matches:', e);
            }
          };

          const refreshData = async () => {
            await loadData();
          };

          // Auto-refresh every 30 seconds
          useEffect(() => {
            if (!currentUser) return;
            const interval = setInterval(refreshData, 30000);
            return () => clearInterval(interval);
          }, [currentUser]);

          const getPlayerAvailability = (player, date) => availability[player]?.[date] || [];

          const toggleSlot = async (time) => {
            if (!currentUser) return;
            const playerData = availability[currentUser] || {};
            const dateSlots = playerData[selectedDate] || [];
            const newSlots = dateSlots.includes(time) ? dateSlots.filter(t => t !== time) : [...dateSlots, time];
            const newAvail = { ...availability, [currentUser]: { ...playerData, [selectedDate]: newSlots } };
            await saveAvailability(newAvail);
          };

          const selectAllSlots = async () => {
            if (!currentUser) return;
            const playerData = availability[currentUser] || {};
            const newAvail = { ...availability, [currentUser]: { ...playerData, [selectedDate]: [...timeSlots] } };
            await saveAvailability(newAvail);
          };

          const clearSlots = async () => {
            if (!currentUser) return;
            const playerData = availability[currentUser] || {};
            const newAvail = { ...availability, [currentUser]: { ...playerData, [selectedDate]: [] } };
            await saveAvailability(newAvail);
          };

          const isSlotConflict = (player, date, time, excludeMatchId) => {
            return Object.values(matches).some(m =>
              m.id !== excludeMatchId && m.lockedDate === date && m.lockedTime === time && (m.player1 === player || m.player2 === player)
            );
          };

          const getCommonSlots = (match) => {
            const common = [];
            dates.forEach(date => {
              const p1Slots = getPlayerAvailability(match.player1, date);
              const p2Slots = getPlayerAvailability(match.player2, date);
              p1Slots.forEach(time => {
                if (p2Slots.includes(time)) {
                  const conflict = isSlotConflict(match.player1, date, time, match.id) || isSlotConflict(match.player2, date, time, match.id);
                  common.push({ date, time, conflict });
                }
              });
            });
            return common;
          };

          const lockTime = async (matchId, date, time) => {
            const newMatches = { ...matches, [matchId]: { ...matches[matchId], lockedDate: date, lockedTime: time } };
            await saveMatches(newMatches);
          };

          const unlockTime = async (matchId) => {
            const newMatches = { ...matches, [matchId]: { ...matches[matchId], lockedDate: null, lockedTime: null } };
            await saveMatches(newMatches);
          };

          const completeMatch = async (matchId, winner, score1, score2) => {
            const newMatches = { ...matches, [matchId]: { ...matches[matchId], winner, score1, score2, completed: true } };
            await saveMatches(newMatches);
          };

          const reopenMatch = async (matchId) => {
            const newMatches = { ...matches, [matchId]: { ...matches[matchId], winner: null, score1: null, score2: null, completed: false } };
            await saveMatches(newMatches);
          };

          const groupMatches = Object.values(matches).filter(m => m.group === activeGroup);
          const completed = groupMatches.filter(m => m.completed).length;
          const scheduled = groupMatches.filter(m => m.lockedTime).length;
          const total = groupMatches.length;
          const userGroup = currentUser ? getPlayerGroup(currentUser) : null;

          if (loading) {
            return <div className="min-h-screen bg-slate-950 text-slate-100 flex items-center justify-center">Loading...</div>;
          }

          if (!currentUser) {
            return (
              <div className="min-h-screen bg-slate-950 text-slate-100 p-4">
                <div className="max-w-md mx-auto pt-12">
                  <div className="text-center mb-8">
                    <h1 className="text-2xl font-light tracking-wide mb-2">üèì Tournament Scheduler</h1>
                    <p className="text-slate-500 text-sm">Select your name to continue</p>
                  </div>
                  <div className="space-y-3">
                    {Object.entries(groups).map(([group, players]) => (
                      <div key={group} className="bg-slate-900 rounded-xl p-3">
                        <p className="text-violet-400 text-xs font-semibold mb-2">Group {group}</p>
                        <div className="grid grid-cols-2 gap-2">
                          {players.map(player => (
                            <button key={player} onClick={() => { setCurrentUser(player); setActiveGroup(group); }}
                              className="p-2 bg-slate-800 hover:bg-violet-600 rounded-lg text-sm text-left truncate transition">
                              {player}
                            </button>
                          ))}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            );
          }

          return (
            <div className="min-h-screen bg-slate-950 text-slate-100 p-4">
              <div className="max-w-2xl mx-auto">
                <div className="flex items-center justify-between mb-4">
                  <div>
                    <h1 className="text-lg font-light">üèì Tournament</h1>
                    <p className="text-violet-400 text-sm">{currentUser} <span className="text-slate-600">‚Ä¢ Group {userGroup}</span></p>
                  </div>
                  <div className="flex gap-2">
                    <button onClick={refreshData} className="text-xs bg-slate-800 hover:bg-slate-700 px-3 py-1.5 rounded-lg">‚Üª Refresh</button>
                    <button onClick={() => setCurrentUser(null)} className="text-xs bg-slate-800 hover:bg-slate-700 px-3 py-1.5 rounded-lg">Switch</button>
                  </div>
                </div>

                <div className="flex justify-center mb-4">
                  <div className="bg-slate-900 rounded-full p-1 inline-flex">
                    <button onClick={() => setView('availability')} className={`px-4 py-1.5 rounded-full text-sm transition ${view === 'availability' ? 'bg-slate-700 text-white' : 'text-slate-400'}`}>My Availability</button>
                    <button onClick={() => setView('matches')} className={`px-4 py-1.5 rounded-full text-sm transition ${view === 'matches' ? 'bg-slate-700 text-white' : 'text-slate-400'}`}>Matches</button>
                  </div>
                </div>

                {view === 'availability' && (
                  <div className="bg-slate-900 rounded-2xl p-4">
                    <div className="flex justify-between items-center mb-4">
                      <p className="text-slate-500 text-xs uppercase tracking-wider">Select Date</p>
                      <div className="flex gap-1">
                        {dates.map(d => (
                          <button key={d} onClick={() => setSelectedDate(d)}
                            className={`px-3 py-1.5 rounded-lg text-sm transition ${selectedDate === d ? 'bg-violet-600 text-white' : 'bg-slate-800 text-slate-400'}`}>{d}</button>
                        ))}
                      </div>
                    </div>

                    <div className="flex justify-between items-center mb-2">
                      <p className="text-slate-500 text-xs uppercase tracking-wider">Your Time Slots</p>
                      <div className="flex gap-2">
                        <button onClick={selectAllSlots} className="text-xs text-violet-400 hover:text-violet-300">Select All</button>
                        <button onClick={clearSlots} className="text-xs text-slate-500 hover:text-slate-400">Clear</button>
                      </div>
                    </div>

                    <div className="grid grid-cols-6 gap-1.5">
                      {timeSlots.map(time => {
                        const isSelected = getPlayerAvailability(currentUser, selectedDate).includes(time);
                        return (
                          <button key={time} onClick={() => toggleSlot(time)}
                            className={`py-2 text-xs rounded-lg transition ${isSelected ? 'bg-emerald-500 text-white' : 'bg-slate-800 text-slate-400 hover:bg-slate-700'}`}>{formatTime(time)}</button>
                        );
                      })}
                    </div>

                    <div className="mt-4 pt-4 border-t border-slate-800">
                      <p className="text-slate-500 text-xs mb-2">Your availability summary:</p>
                      <div className="flex gap-2 flex-wrap">
                        {dates.map(d => {
                          const count = getPlayerAvailability(currentUser, d).length;
                          return (
                            <span key={d} className={`text-xs px-2 py-1 rounded-lg ${count > 0 ? 'bg-emerald-500/20 text-emerald-400' : 'bg-slate-800 text-slate-500'}`}>
                              {d}: {count} slots
                            </span>
                          );
                        })}
                      </div>
                    </div>
                  </div>
                )}

                {view === 'matches' && (
                  <>
                    <div className="flex justify-center gap-2 mb-4">
                      {Object.keys(groups).map(g => (
                        <button key={g} onClick={() => setActiveGroup(g)}
                          className={`w-10 h-10 rounded-xl text-sm font-semibold transition ${activeGroup === g ? 'bg-violet-600 text-white' : 'bg-slate-800 text-slate-400 hover:bg-slate-700'}`}>{g}</button>
                      ))}
                    </div>

                    <div className="bg-slate-900 rounded-2xl p-4">
                      <div className="flex justify-between items-center mb-4">
                        <p className="text-slate-500 text-xs uppercase tracking-wider">Group {activeGroup} Matches</p>
                        <div className="flex gap-2">
                          <span className="text-xs px-2 py-1 rounded-full bg-emerald-500/20 text-emerald-400">{completed}/{total} done</span>
                          <span className={`text-xs px-2 py-1 rounded-full ${scheduled === total ? 'bg-violet-500/20 text-violet-400' : 'bg-amber-500/20 text-amber-400'}`}>{scheduled}/{total} scheduled</span>
                        </div>
                      </div>

                      <div className="space-y-3">
                        {groupMatches.map(match => {
                          const commonSlots = getCommonSlots(match);
                          const isLocked = match.lockedTime;
                          const isMyMatch = match.player1 === currentUser || match.player2 === currentUser;
                          return (
                            <div key={match.id} className={`p-3 rounded-xl ${match.completed ? 'bg-slate-800/50 border border-slate-700' : isLocked ? 'bg-emerald-900/20 border border-emerald-800/50' : isMyMatch ? 'bg-violet-900/20 border border-violet-800/50' : 'bg-slate-800'}`}>
                              <div className="flex items-center justify-between mb-2">
                                <div className="text-sm">
                                  <span className={`${match.completed && match.winner === match.player1 ? 'text-emerald-400 font-semibold' : 'text-slate-300'} ${match.player1 === currentUser ? 'underline' : ''}`}>{match.player1}</span>
                                  <span className="text-slate-600 mx-2">vs</span>
                                  <span className={`${match.completed && match.winner === match.player2 ? 'text-emerald-400 font-semibold' : 'text-slate-300'} ${match.player2 === currentUser ? 'underline' : ''}`}>{match.player2}</span>
                                </div>
                                {isLocked && <button onClick={() => unlockTime(match.id)} className="text-xs text-slate-500 hover:text-red-400">‚úï</button>}
                              </div>

                              {isLocked ? (
                                <div className="space-y-2">
                                  <div className="flex items-center justify-between">
                                    <span className="text-xs bg-emerald-500/30 text-emerald-300 px-2 py-1 rounded-lg inline-block">üîí {match.lockedDate} @ {formatTime(match.lockedTime)}</span>
                                    {match.completed && <span className="text-xs bg-violet-500/30 text-violet-300 px-2 py-1 rounded-lg">‚úì Complete</span>}
                                  </div>

                                  {match.completed ? (
                                    <div className="flex items-center justify-between bg-slate-800/50 rounded-lg p-2">
                                      <div className="text-sm">
                                        <span className={match.winner === match.player1 ? 'text-emerald-400 font-semibold' : 'text-slate-400'}>{match.player1.split(' ')[0]}</span>
                                        <span className="text-slate-500 mx-2">{match.score1} - {match.score2}</span>
                                        <span className={match.winner === match.player2 ? 'text-emerald-400 font-semibold' : 'text-slate-400'}>{match.player2.split(' ')[0]}</span>
                                      </div>
                                      <button onClick={() => reopenMatch(match.id)} className="text-xs text-slate-500 hover:text-amber-400">Edit</button>
                                    </div>
                                  ) : (
                                    <MatchResultForm match={match} onComplete={completeMatch} />
                                  )}
                                </div>
                              ) : (
                                <div className="flex flex-wrap gap-1">
                                  {commonSlots.length === 0 ? (
                                    <span className="text-red-400 text-xs">No common availability</span>
                                  ) : (
                                    commonSlots.map((slot, i) => (
                                      <button key={i} onClick={() => !slot.conflict && lockTime(match.id, slot.date, slot.time)}
                                        className={`text-xs px-2 py-1 rounded-lg transition ${slot.conflict ? 'bg-red-900/30 text-red-400 cursor-not-allowed line-through' : 'bg-slate-700 text-slate-300 hover:bg-violet-600 hover:text-white'}`}
                                        title={slot.conflict ? 'Conflict' : 'Click to lock'}>{slot.date} {formatTime(slot.time)}</button>
                                    ))
                                  )}
                                </div>
                              )}
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  </>
                )}
              </div>
            </div>
          );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
